"""
Bot Telegram - Petya Search v0.0.1
Python 3.11+ | python-telegram-bot==20.7 | reportlab
"""

import logging
import asyncio 
import json, re
import tempfile
import random
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
import threading
import time
import ipaddress
import requests

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters
)
from telegram.constants import ParseMode
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib import colors
# ==================== CONFIGURA√á√ïES NO TOPO ====================
TOKEN = "8248285817:AAGtOpEMXKNQEz0RsxmGienjuYnGVmQvMZQ"
ADMIN_ID = 6939434522
BOT_NAME = "Petya Search"
BOT_VERSION = "v0.0.1"

# ==================== LOGGING ====================
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== PATHS ====================
BASE_DIR = Path("petya search")
DATA_DIR = BASE_DIR / "base-dados"
DONOS_DIR = BASE_DIR / "donos"

USER_FILE = DATA_DIR / "user.json"
LOGS_FILE = DATA_DIR / "logs.json"
CONFIG_FILE = DONOS_DIR / "config-all.json"
MENU_PHOTO = BASE_DIR / "menu_photo.jpg"

# ==================== CRIA√á√ÉO DE ESTRUTURA ====================
def create_structure():
    """Cria diret√≥rios e arquivos necess√°rios"""
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    DONOS_DIR.mkdir(parents=True, exist_ok=True)
    
    if not CONFIG_FILE.exists():
        config = {
            "bot_name": BOT_NAME,
            "version": BOT_VERSION,
            "admins": [ADMIN_ID],
            "greeting": "Ol√°! Bem-vindo ao bot.",
            "token": TOKEN,
            "bans": [],
            "bot_on": True,
            "suporte_message": "Ol√°, preciso de ajuda com o bot!"
        }
        CONFIG_FILE.write_text(json.dumps(config, indent=2, ensure_ascii=False))
    
    if not USER_FILE.exists():
        USER_FILE.write_text("[]")
    
    if not LOGS_FILE.exists():
        LOGS_FILE.write_text("{}")

# ==================== FUN√á√ïES AUXILIARES ====================
def load_json(file_path: Path) -> Any:
    """Carrega arquivo JSON"""
    try:
        return json.loads(file_path.read_text(encoding='utf-8'))
    except:
        return [] if file_path == USER_FILE else {}

def save_json(file_path: Path, data: Any):
    """Salva dados em JSON"""
    file_path.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding='utf-8')

def get_config() -> Dict:
    """Retorna configura√ß√£o"""
    return load_json(CONFIG_FILE)

def save_config(config: Dict):
    """Salva configura√ß√£o"""
    save_json(CONFIG_FILE, config)

def get_users() -> List[Dict]:
    """Retorna lista de usu√°rios"""
    return load_json(USER_FILE)

def save_users(users: List[Dict]):
    """Salva lista de usu√°rios"""
    save_json(USER_FILE, users)

def get_logs() -> Dict:
    """Retorna logs"""
    return load_json(LOGS_FILE)

def save_logs(logs: Dict):
    """Salva logs"""
    save_json(LOGS_FILE, logs)

def add_log(user_id: int, action: str, details: str = ""):
    """Adiciona log de a√ß√£o do usu√°rio"""
    logs = get_logs()
    user_id_str = str(user_id)
    
    if user_id_str not in logs:
        logs[user_id_str] = []
    
    log_entry = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "action": action,
        "details": details
    }
    
    logs[user_id_str].append(log_entry)
    save_logs(logs)

def is_admin(user_id: int) -> bool:
    """Verifica se usu√°rio √© admin"""
    config = get_config()
    return user_id in config.get("admins", [])

def is_banned(user_id: int) -> bool:
    """Verifica se usu√°rio est√° banido"""
    config = get_config()
    return user_id in config.get("bans", [])

def is_bot_on() -> bool:
    """Verifica se bot est√° ativo"""
    config = get_config()
    return config.get("bot_on", True)

def is_vip(user_id: int) -> bool:
    """Verifica se usu√°rio √© VIP"""
    users = get_users()
    for user in users:
        if user.get("id") == user_id:
            if user.get("vip", False):
                vip_until = user.get("vip_until")
                if vip_until:
                    vip_date = datetime.fromisoformat(vip_until)
                    if datetime.now() < vip_date:
                        return True
                    else:
                        user["vip"] = False
                        user["vip_until"] = None
                        save_users(users)
                        return False
            return False
    return False

def parse_time_duration(duration_str: str) -> Optional[timedelta]:
    """
    Parse duration string like '20s', '30m', '24h', '7d'
    Returns timedelta or None
    """
    try:
        unit = duration_str[-1].lower()
        value = int(duration_str[:-1])
        
        if unit == 's':
            return timedelta(seconds=value)
        elif unit == 'm':
            return timedelta(minutes=value)
        elif unit == 'h':
            return timedelta(hours=value)
        elif unit == 'd':
            return timedelta(days=value)
        else:
            return None
    except:
        return None

async def send_to_admin(context: ContextTypes.DEFAULT_TYPE, message: str):
    """Envia mensagem para admin"""
    try:
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logger.error(f"Erro ao enviar para admin: {e}")

def get_user_data(user_id: int) -> Optional[Dict]:
    """Retorna dados do usu√°rio"""
    users = get_users()
    for user in users:
        if user.get("id") == user_id:
            return user
    return None

# ==================== FUN√á√ÉO CRIAR DESIGN (SEPARADA) ====================
def gerar_pdf_design(output_path: str) -> str:
    """
    Gera PDF com design azul e roxo
    Retorna o caminho do arquivo gerado
    """
    c = canvas.Canvas(output_path, pagesize=A4)
    width, height = A4
    
    num_strips = 100
    for i in range(num_strips):
        ratio = i / num_strips
        r = int(138 * ratio + 0 * (1 - ratio))
        g = int(43 * ratio + 0 * (1 - ratio))
        b = int(226 * ratio + 255 * (1 - ratio))
        
        c.setFillColorRGB(r/255, g/255, b/255)
        c.rect(0, height - (i+1) * (height/num_strips), width, height/num_strips, fill=1, stroke=0)
    
    c.setFillColorRGB(1, 1, 1)
    c.setFont("Helvetica-Bold", 24)
    c.drawCentredString(width/2, height/2, f"{BOT_NAME} - Design")
    
    c.save()
    return output_path

async def pkg_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    username = update.effective_user.username or f"user{user_id}"

    nome = context.args[0] if len(context.args) > 0 else username
    github = context.args[1] if len(context.args) > 1 else username
    versao = context.args[2] if len(context.args) > 2 else "1.0.0"
    deps_str = context.args[3] if len(context.args) > 3 else ""
    license_ = context.args[4] if len(context.args) > 4 else "MIT"
    scripts_str = context.args[5] if len(context.args) > 5 else "start=node index.js"
    dev_deps_str = context.args[6] if len(context.args) > 6 else ""
    keywords_str = context.args[7] if len(context.args) > 7 else f"{username},bot,package"
    node_version = context.args[8] if len(context.args) > 8 else ">=14.0.0"

    nome = re.sub(r"[^a-zA-Z0-9_-]", "-", nome.lower())

    deps_list = [dep.strip() for dep in deps_str.split(",") if dep.strip()]
    dependencies = {dep: "*" for dep in deps_list}

    dev_deps_list = [dep.strip() for dep in dev_deps_str.split(",") if dep.strip()]
    devDependencies = {dep: "*" for dep in dev_deps_list}

    scripts = {}
    for s in scripts_str.split(","):
        if "=" in s:
            k, v = s.split("=", 1)
            scripts[k.strip()] = v.strip()

    keywords = [kw.strip() for kw in keywords_str.split(",") if kw.strip()]

    repository = {}
    bugs = {}
    homepage = ""
    if github.startswith("http://") or github.startswith("https://"):
        repository = {"type": "git", "url": github}
        bugs = {"url": f"{github}/issues"}
        homepage = github
    else:
        repository = {"type": "git", "url": f"https://github.com/{github}/{nome}.git"}
        bugs = {"url": f"https://github.com/{github}/{nome}/issues"}
        homepage = f"https://github.com/{github}/{nome}"

    package_json = {
        "name": nome,
        "version": versao,
        "description": f"Projeto gerado pelo bot para {github}",
        "main": "index.js",
        "scripts": scripts,
        "author": github,
        "license": license_,
        "dependencies": dependencies,
        "devDependencies": devDependencies,
        "repository": repository,
        "bugs": bugs,
        "homepage": homepage,
        "keywords": keywords,
        "engines": {"node": node_version}
    }

    json_text = json.dumps(package_json, indent=2, ensure_ascii=False)

    await update.message.reply_text(
        f"<blockquote><pre>{json_text}</pre></blockquote>",
        parse_mode="HTML"
    )


DATA_DIR = BASE_DIR / "data"
DATA_DIR.mkdir(exist_ok=True)

PESQUISAS_JSON = DATA_DIR / "pesquisas_ip.json"
if not PESQUISAS_JSON.exists():
    PESQUISAS_JSON.write_text("[]", encoding="utf-8")

FRASES_BIBLICA = [
    "Tudo posso naquele que me fortalece. (Filipenses 4:13)",
    "O Senhor √© meu pastor; nada me faltar√°. (Salmo 23:1)",
    "Entrega o teu caminho ao Senhor; confia nele, e o mais ele far√°. (Salmo 37:5)",
    "Confia no Senhor de todo o teu cora√ß√£o. (Prov√©rbios 3:5)"
]

async def ip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name
    if is_banned(user_id):
        return
    if not context.args:
        await update.message.reply_text("Use: /ip <endere√ßo_ip>")
        return
    ip = context.args[0].strip()
    add_log(user_id, "comando", f"/ip {ip}")
    try:
        ip_obj = ipaddress.ip_address(ip)
        ip_type = "IPv4" if ip_obj.version == 4 else "IPv6"
    except:
        await update.message.reply_text("Endere√ßo IP inv√°lido. Informe um IPv4 ou IPv6 v√°lido.")
        return
    await update.message.reply_text(f"üîé Consultando {ip} ({ip_type})...")
    try:
        resp = requests.get(
            f"http://ip-api.com/json/{ip}",
            params={"fields": "status,message,country,countryCode,region,regionName,city,zip,isp,org,as,query,lat,lon,timezone,reverse,mobile,proxy,hosting"},
            timeout=10
        )
        data = resp.json()
    except:
        await update.message.reply_text("Erro ao consultar servi√ßo externo. Tente novamente mais tarde.")
        return
    if data.get("status") != "success":
        await update.message.reply_text(f"Falha ao localizar IP: {data.get('message', 'erro desconhecido')}")
        return
    celular = "Desconhecido"
    if data.get("mobile") is True:
        celular = "Smartphone / dispositivo m√≥vel"
    elif data.get("mobile") is False:
        celular = "Computador / Desktop"
    frase_dia = random.choice(FRASES_BIBLICA)
    resultado_dict = {
        "status": "sucesso",
        "mensagem": "Consulta realizada com sucesso",
        "ip": data.get("query"),
        "tipo": ip_type,
        "celular": celular,
        "localizacao": {
            "pais": data.get("country"),
            "codigo_pais": data.get("countryCode"),
            "estado": data.get("regionName"),
            "cidade": data.get("city"),
            "cep": data.get("zip") or "n√£o dispon√≠vel",
            "latitude": data.get("lat"),
            "longitude": data.get("lon"),
            "timezone": data.get("timezone"),
            "link_maps": f"https://www.google.com/maps?q={data.get('lat')},{data.get('lon')}"
        },
        "rede": {
            "isp": data.get("isp"),
            "org": data.get("org"),
            "as": data.get("as"),
            "hosting": data.get("hosting"),
            "proxy": data.get("proxy"),
            "mobile": data.get("mobile"),
            "reverse_dns": data.get("reverse")
        },
        "frase_dia": frase_dia
    }
    try:
        pesquisas = json.loads(PESQUISAS_JSON.read_text(encoding="utf-8"))
    except:
        pesquisas = []
    pesquisas.append({
        "usuario_id": user_id,
        "usuario_nome": username,
        "ip_pesquisado": ip,
        "resultado": resultado_dict,
        "timestamp": int(time.time())
    })
    PESQUISAS_JSON.write_text(json.dumps(pesquisas, indent=2, ensure_ascii=False), encoding="utf-8")
    await update.message.reply_text(
        f"<blockquote><pre>{json.dumps(resultado_dict, indent=2, ensure_ascii=False)}</pre></blockquote>",
        parse_mode=ParseMode.HTML
    )
    aviso = f"Usu√°rio {username} ({user_id}) pesquisou o IP: {ip}"
    await context.bot.send_message(chat_id=ADMIN_ID, text=aviso)
    
    
#========= ALGUNS COMANDOS 

async def userinfo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    target = None
    if context.args:
        arg = context.args[0]
        if arg.isdigit():
            target = await context.bot.get_chat(int(arg))
        else:
            target = await context.bot.get_chat(arg)
    else:
        target = update.effective_user

    already_used = False
    users = get_users()
    for u in users:
        if u.get("id") == target.id:
            already_used = True
            break

    user_data = {
        "id": target.id,
        "nome": target.first_name,
        "username": target.username or "n√£o possui",
        "bio": getattr(target, "bio", "n√£o possui"),
        "ja_usou_o_bot": already_used
    }

    photos = await context.bot.get_user_profile_photos(target.id, limit=1)
    if photos.total_count > 0:
        file = await context.bot.get_file(photos.photos[0][-1].file_id)
        await update.message.reply_photo(photo=file.file_id, caption="üì∏ Foto do usu√°rio")

    await update.message.reply_text(
        f"<pre>{json.dumps(user_data, indent=2, ensure_ascii=False)}</pre>",
        parse_mode="HTML"
    )

async def crypto_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    coin = context.args[0].lower() if context.args else "bitcoin"
    try:
        resp = requests.get(f"https://api.coingecko.com/api/v3/simple/price?ids={coin}&vs_currencies=usd")
        data = resp.json()
        if coin not in data:
            await update.message.reply_text(f"Moeda '{coin}' n√£o encontrada")
            return
        result = {"moeda": coin, "preco_usd": data[coin]["usd"]}
        await update.message.reply_text(
            f"<pre>{json.dumps(result, indent=2, ensure_ascii=False)}</pre>",
            parse_mode="HTML"
        )
    except Exception as e:
        await update.message.reply_text(f"Erro ao buscar pre√ßo: {e}")

async def cep_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Use: /cep <cep>")
        return
    cep = context.args[0].replace("-", "").strip()
    try:
        resp = requests.get(f"https://viacep.com.br/ws/{cep}/json/")
        data = resp.json()
        await update.message.reply_text(
            f"<pre>{json.dumps(data, indent=2, ensure_ascii=False)}</pre>",
            parse_mode="HTML"
        )
    except Exception as e:
        await update.message.reply_text(f"Erro ao buscar CEP: {e}")

async def html_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    nome = context.args[0] if context.args else "index"
    html_text = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>{nome}</title>
</head>
<body>
  <h1>Ol√°, {nome}!</h1>
</body>
</html>"""
    await update.message.reply_text(f"<pre>{html_text}</pre>", parse_mode="HTML")

async def css_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    nome = context.args[0] if context.args else "style"
    css_text = f"""/* CSS para {nome} */
body {{
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    margin: 0;
    padding: 0;
}}"""
    await update.message.reply_text(f"<pre>{css_text}</pre>", parse_mode="HTML")

async def js_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    nome = context.args[0] if context.args else "script"
    js_text = f"""// JS para {nome}
console.log("Ol√°, {nome}!");"""
    await update.message.reply_text(f"<pre>{js_text}</pre>", parse_mode="HTML")



# ==================== THREAD DE VERIFICA√á√ÉO VIP ====================
def vip_checker_thread(application: Application):
    """Thread que verifica expira√ß√£o de VIP a cada 10 segundos"""
    while True:
        try:
            time.sleep(10)  # Verifica a cada 10 segundos
            users = get_users()
            updated = False
            
            for user in users:
                if user.get("vip", False):
                    vip_until = user.get("vip_until")
                    if vip_until:
                        vip_date = datetime.fromisoformat(vip_until)
                        if datetime.now() >= vip_date:
                            user["vip"] = False
                            user["vip_until"] = None
                            updated = True
                           
                            config = get_config()
                            message = (
                                f"<blockquote>‚è∞ Seu tempo de VIP expirou!</blockquote>\n\n"
                                f"Se deseja adquirir mais tempo VIP, entre em contato com o suporte:"
                            )
                            
                            keyboard = [[
                                InlineKeyboardButton(
                                    "üí¨ Falar com Suporte",
                                    url=f"https://t.me/suporte?text={config.get('suporte_message', 'Ol√°!')}"
                                )
                            ]]
                            reply_markup = InlineKeyboardMarkup(keyboard)
                           
                            import asyncio
                            asyncio.run_coroutine_threadsafe(
                                application.bot.send_message(
                                    chat_id=user["id"],
                                    text=message,
                                    parse_mode=ParseMode.HTML,
                                    reply_markup=reply_markup
                                ),
                                application.bot_data.get('event_loop')
                            )
                            
                            logger.info(f"VIP expirado para usu√°rio {user['id']}")
            
            if updated:
                save_users(users)
                
        except Exception as e:
            logger.error(f"Erro no checker de VIP: {e}")

# ==================== HANDLERS ====================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /start"""
    user = update.effective_user
    
    # Verificar ban
    if is_banned(user.id):
        await update.message.reply_text(
            "<blockquote>Voc√™ est√° banido.</blockquote>",
            parse_mode=ParseMode.HTML
        )
        add_log(user.id, "comando", "/start (banido)")
        return
    
    # Verificar se bot est√° ativo
    if not is_bot_on() and not is_admin(user.id):
        await update.message.reply_text(
            "<blockquote>üîß Bot em manuten√ß√£o. Aguarde...</blockquote>",
            parse_mode=ParseMode.HTML
        )
        return
    
    # Registrar usu√°rio
    users = get_users()
    user_exists = False
    
    for u in users:
        if u.get("id") == user.id:
            user_exists = True
            break
    
    if not user_exists:
        # Pegar foto do perfil
        photos = await context.bot.get_user_profile_photos(user.id, limit=1)
        photo_url = None
        if photos.total_count > 0:
            photo_file = await photos.photos[0][-1].get_file()
            photo_url = photo_file.file_path
        
        user_data = {
            "id": user.id,
            "nome": user.full_name,
            "username": user.username or "sem_username",
            "start_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "photo_url": photo_url,
            "vip": False,
            "vip_until": None
        }
        users.append(user_data)
        save_users(users)
    
    add_log(user.id, "comando", "/start")
    
    # Menu principal
    config = get_config()
    greeting = config.get("greeting", "Ol√°! Bem-vindo ao bot.")
    
    text = (
        f"<blockquote>{greeting}</blockquote>\n\n"
        f"<b>{BOT_NAME} {BOT_VERSION}</b>\n"
        f"Ol√°, <b>{user.full_name}</b>! Escolha uma op√ß√£o:"
    )
    
    keyboard = [
        [InlineKeyboardButton("üîç Google Dork", callback_data="google_dork")],
        [InlineKeyboardButton("üìä Meus Logs", callback_data="my_logs")],
        [InlineKeyboardButton("‚ö†Ô∏è Reportar Erro", callback_data="report_error")],
        [InlineKeyboardButton("üí¨ Suporte", callback_data="suporte")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Verificar se tem foto de menu
    if MENU_PHOTO.exists():
        await update.message.reply_photo(
            photo=open(MENU_PHOTO, 'rb'),
            caption=text,
            parse_mode=ParseMode.HTML,
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            text,
            parse_mode=ParseMode.HTML,
            reply_markup=reply_markup
        )

async def dork_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /dork <termo>"""
    user_id = update.effective_user.id
    
    if is_banned(user_id):
        return
    
    if not context.args:
        await update.message.reply_text("Use: /dork <termo>")
        return
    
    termo = " ".join(context.args)
    add_log(user_id, "comando", f"/dork {termo}")
    
    # Simula√ß√£o de busca
    resultado = (
        f"<b>üîç Resultados para:</b> {termo}\n\n"
        f"<code>site:instagram.com \"{termo}\"</code>\n"
        f"<code>site:facebook.com \"{termo}\"</code>\n"
        f"<code>site:twitter.com \"{termo}\"</code>\n\n"
        f"<i>Busca realizada com sucesso!</i>"
    )
    
    # Salvar em txt
    txt_file = DATA_DIR / f"dork_{user_id}_{int(time.time())}.txt"
    txt_file.write_text(resultado, encoding='utf-8')
    
    await update.message.reply_document(
        document=open(txt_file, 'rb'),
        caption=f"<b>Resultados da busca por:</b> {termo}",
        parse_mode=ParseMode.HTML
    )
    
    txt_file.unlink()  # Remove arquivo tempor√°rio

async def criar_design_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /criar_design"""
    user_id = update.effective_user.id
    
    if is_banned(user_id):
        return
    
    add_log(user_id, "comando", "/criar_design")
    
    await update.message.reply_text("‚è≥ Gerando design...")
    
    # Gerar PDF
    pdf_path = DATA_DIR / f"design_{user_id}_{int(time.time())}.pdf"
    gerar_pdf_design(str(pdf_path))
    
    await update.message.reply_document(
        document=open(pdf_path, 'rb'),
        caption="<b>‚ú® Design criado com sucesso!</b>",
        parse_mode=ParseMode.HTML
    )
    
    pdf_path.unlink()  # Remove arquivo tempor√°rio

async def suporte_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /suporte"""
    user_id = update.effective_user.id
    
    if is_banned(user_id):
        return
    
    add_log(user_id, "comando", "/suporte")
    
    config = get_config()
    suporte_msg = config.get("suporte_message", "Ol√°, preciso de ajuda!")
    
    text = "<b>üí¨ Suporte</b>\n\nEntre em contato: @suporte"
    keyboard = [[
        InlineKeyboardButton(
            "üí¨ Enviar mensagem",
            url=f"https://t.me/suporte?text={suporte_msg}"
        )
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        text,
        parse_mode=ParseMode.HTML,
        reply_markup=reply_markup
    )

async def search_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /search-id <id> (VIP only)"""
    user_id = update.effective_user.id
    
    if is_banned(user_id):
        return
    
    # Verificar se √© VIP
    if not is_vip(user_id) and not is_admin(user_id):
        # Ignorar comando
        return
    
    if not context.args:
        await update.message.reply_text("Use: /search-id <id>")
        return
    
    try:
        target_id = int(context.args[0])
    except:
        await update.message.reply_text("ID inv√°lido!")
        return
    
    add_log(user_id, "comando", f"/search-id {target_id}")
    
    # Buscar perfil
    try:
        target_user = await context.bot.get_chat(target_id)
        
        # Pegar foto
        photos = await context.bot.get_user_profile_photos(target_id, limit=1)
        photo_url = None
        if photos.total_count > 0:
            photo_file = await photos.photos[0][-1].get_file()
            photo_url = photo_file.file_path
        
        text = (
            f"<b>üë§ Informa√ß√µes do usu√°rio {target_id}:</b>\n\n"
            f"<b>Nome:</b> {target_user.full_name}\n"
            f"<b>Username:</b> @{target_user.username or 'sem username'}\n"
            f"<b>ID:</b> <code>{target_id}</code>\n"
        )
        
        if photo_url:
            text += f"\n<b>Foto:</b> {photo_url}"
        
        await update.message.reply_text(text, parse_mode=ParseMode.HTML)
        
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro ao buscar usu√°rio: {e}")

# ==================== ADMIN COMMANDS ====================
async def ban_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /ban <id>"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        await update.message.reply_text("Use: /ban <id>")
        return
    
    try:
        target_id = int(context.args[0])
        config = get_config()
        
        if target_id not in config["bans"]:
            config["bans"].append(target_id)
            save_config(config)
            await update.message.reply_text(f"‚úÖ Usu√°rio {target_id} banido!")
            add_log(update.effective_user.id, "admin", f"ban {target_id}")
        else:
            await update.message.reply_text(f"Usu√°rio {target_id} j√° est√° banido.")
    except:
        await update.message.reply_text("ID inv√°lido!")

async def unban_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /unban <id>"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        await update.message.reply_text("Use: /unban <id>")
        return
    
    try:
        target_id = int(context.args[0])
        config = get_config()
        
        if target_id in config["bans"]:
            config["bans"].remove(target_id)
            save_config(config)
            await update.message.reply_text(f"‚úÖ Usu√°rio {target_id} desbanido!")
            add_log(update.effective_user.id, "admin", f"unban {target_id}")
        else:
            await update.message.reply_text(f"Usu√°rio {target_id} n√£o est√° banido.")
    except:
        await update.message.reply_text("ID inv√°lido!")

async def vip_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /vip <id> <tempo>"""
    if not is_admin(update.effective_user.id):
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("Use: /vip <id> <tempo>\nExemplo: /vip 123456 24h")
        return
    
    try:
        target_id = int(context.args[0])
        duration_str = context.args[1]
        
        duration = parse_time_duration(duration_str)
        if not duration:
            await update.message.reply_text("Formato de tempo inv√°lido! Use: 20s, 30m, 24h, 7d")
            return
        
        vip_until = datetime.now() + duration
        
        users = get_users()
        user_found = False
        
        for user in users:
            if user.get("id") == target_id:
                user["vip"] = True
                user["vip_until"] = vip_until.isoformat()
                user_found = True
                break
        
        if not user_found:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado na base de dados!")
            return
        
        save_users(users)
        
        # Notificar admin
        await update.message.reply_text(
            f"‚úÖ Usu√°rio {target_id} agora √© VIP at√© {vip_until.strftime('%Y-%m-%d %H:%M:%S')}"
        )
        
        # Notificar usu√°rio
        user_data = get_user_data(target_id)
        nome = user_data.get("nome", "Usu√°rio") if user_data else "Usu√°rio"
        
        message = (
            f"<blockquote>üåü Parab√©ns, {nome}!</blockquote>\n\n"
            f"Voc√™ acaba de se tornar <b>VIP</b> em nosso bot <b>{BOT_NAME}</b>!\n\n"
            f"<b>Dura√ß√£o:</b> {duration_str}\n"
            f"<b>V√°lido at√©:</b> {vip_until.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            f"<i>Aproveite seus benef√≠cios exclusivos!</i>"
        )
        
        await context.bot.send_message(
            chat_id=target_id,
            text=message,
            parse_mode=ParseMode.HTML
        )
        
        add_log(update.effective_user.id, "admin", f"vip {target_id} {duration_str}")
        
    except ValueError:
        await update.message.reply_text("ID inv√°lido!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")

async def del_vip_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /del-vip <id>"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        await update.message.reply_text("Use: /del-vip <id>")
        return
    
    try:
        target_id = int(context.args[0])
        
        users = get_users()
        user_found = False
        
        for user in users:
            if user.get("id") == target_id:
                user["vip"] = False
                user["vip_until"] = None
                user_found = True
                break
        
        if not user_found:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado!")
            return
        
        save_users(users)
        
        # Notificar admin
        await update.message.reply_text(f"‚úÖ VIP removido do usu√°rio {target_id}")
        
        # Notificar usu√°rio
        config = get_config()
        message = (
            f"<blockquote>‚ö†Ô∏è Seu VIP foi removido</blockquote>\n\n"
            f"Voc√™ perdeu seu acesso VIP no bot <b>{BOT_NAME}</b>.\n\n"
            f"Se deseja ter novamente, entre em contato com o suporte:"
        )
        
        keyboard = [[
            InlineKeyboardButton(
                "üí¨ Falar com Suporte",
                url=f"https://t.me/suporte?text={config.get('suporte_message', 'Ol√°!')}"
            )
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=target_id,
            text=message,
            parse_mode=ParseMode.HTML,
            reply_markup=reply_markup
        )
        
        add_log(update.effective_user.id, "admin", f"del-vip {target_id}")
        
    except ValueError:
        await update.message.reply_text("ID inv√°lido!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")

async def bot_maintenance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /botoff"""
    if not is_admin(update.effective_user.id):
        return
    
    config = get_config()
    config["bot_on"] = False
    save_config(config)
    
    await update.message.reply_text("üîß Bot em manuten√ß√£o!")
    
    # Notificar todos os usu√°rios
    users = get_users()
    for user in users:
        if user["id"] != update.effective_user.id:
            try:
                await context.bot.send_message(
                    chat_id=user["id"],
                    text="<blockquote>üîß Bot em manuten√ß√£o. Voltamos em breve!</blockquote>",
                    parse_mode=ParseMode.HTML
                )
            except:
                pass
    
    add_log(update.effective_user.id, "admin", "botoff")

async def bot_online(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /boton"""
    if not is_admin(update.effective_user.id):
        return
    
    config = get_config()
    config["bot_on"] = True
    save_config(config)
    
    await update.message.reply_text("‚úÖ Bot online!")
    
    # Notificar todos os usu√°rios
    users = get_users()
    for user in users:
        if user["id"] != update.effective_user.id:
            try:
                await context.bot.send_message(
                    chat_id=user["id"],
                    text="<blockquote>‚úÖ Bot est√° online novamente!</blockquote>",
                    parse_mode=ParseMode.HTML
                )
            except:
                pass
    
    add_log(update.effective_user.id, "admin", "boton")

async def ids_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /ids - Lista todos usu√°rios (paginado)"""
    if not is_admin(update.effective_user.id):
        return
    
    users = get_users()
    
    if not users:
        await update.message.reply_text("Nenhum usu√°rio registrado.")
        return
    
    # Paginar: 50 por p√°gina
    page = 0
    if context.args:
        try:
            page = int(context.args[0])
        except:
            pass
    
    per_page = 50
    start_idx = page * per_page
    end_idx = start_idx + per_page
    
    users_page = users[start_idx:end_idx]
    
    text = f"<b>üë• Usu√°rios Registrados (P√°gina {page + 1}):</b>\n\n"
    
    for user in users_page:
        text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        text += f"<b>Nome:</b> {user.get('nome', 'N/A')}\n"
        text += f"<b>Username:</b> @{user.get('username', 'sem username')}\n"
        text += f"<b>ID:</b> <code>{user.get('id')}</code>\n"
        text += f"<b>Start:</b> {user.get('start_date', 'N/A')}\n"
    
    text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    text += f"\n<i>Total: {len(users)} usu√°rios</i>"
    
    # Bot√µes de navega√ß√£o
    keyboard = []
    nav_buttons = []
    
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("¬´ Anterior", callback_data=f"ids_page_{page-1}"))
    
    if end_idx < len(users):
        nav_buttons.append(InlineKeyboardButton("Pr√≥ximo ¬ª", callback_data=f"ids_page_{page+1}"))
    
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    keyboard.append([InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    add_log(update.effective_user.id, "admin", "ids")

async def info_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /info_id <id>"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        await update.message.reply_text("Use: /info_id <id>")
        return
    
    try:
        target_id = int(context.args[0])
        
        # Buscar dados do usu√°rio
        user_data = get_user_data(target_id)
        
        if not user_data:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado!")
            return
        
        # Buscar logs
        logs = get_logs()
        user_logs = logs.get(str(target_id), [])
        
        # √öltimo comando
        last_command = "Nenhum"
        for log in reversed(user_logs):
            if log.get("action") == "comando":
                last_command = f"{log['details']} em {log['timestamp']}"
                break
        
        text = (
            f"<b>üë§ Informa√ß√µes do Usu√°rio:</b>\n\n"
            f"<b>Nome:</b> {user_data.get('nome', 'N/A')}\n"
            f"<b>Username:</b> @{user_data.get('username', 'sem username')}\n"
            f"<b>ID:</b> <code>{target_id}</code>\n"
            f"<b>Start:</b> {user_data.get('start_date', 'N/A')}\n"
            f"<b>VIP:</b> {'‚úÖ Sim' if user_data.get('vip', False) else '‚ùå N√£o'}\n"
            f"<b>√öltimo comando:</b> {last_command}\n"
            f"<b>Total de logs:</b> {len(user_logs)}"
        )
        
        if user_data.get("photo_url"):
            text += f"\n\n<b>Foto:</b> <a href='{user_data['photo_url']}'>Ver foto</a>"
        
        await update.message.reply_text(text, parse_mode=ParseMode.HTML)
        
        # Enviar logs como arquivo
        if user_logs:
            logs_txt = f"Logs do usu√°rio {target_id} - {user_data.get('nome')}\n\n"
            for log in user_logs:
                logs_txt += f"[{log['timestamp']}] {log['action']}: {log.get('details', '')}\n"
            
            txt_file = DATA_DIR / f"logs_{target_id}.txt"
            txt_file.write_text(logs_txt, encoding='utf-8')
            
            await update.message.reply_document(
                document=open(txt_file, 'rb'),
                caption=f"<b>üìã Logs completos do usu√°rio {target_id}</b>",
                parse_mode=ParseMode.HTML
            )
            
            txt_file.unlink()
        
        add_log(update.effective_user.id, "admin", f"info_id {target_id}")
        
    except ValueError:
        await update.message.reply_text("ID inv√°lido!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")

async def fotomenu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /fotomenu"""
    if not is_admin(update.effective_user.id):
        return
    
    await update.message.reply_text("üì∏ Envie a foto que deseja usar como menu:")
    context.user_data['waiting_menu_photo'] = True
    add_log(update.effective_user.id, "admin", "fotomenu")

async def rm_fotomenu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler /rm_foto-menu"""
    if not is_admin(update.effective_user.id):
        return
    
    if MENU_PHOTO.exists():
        MENU_PHOTO.unlink()
        await update.message.reply_text("‚úÖ Foto do menu removida!")
        add_log(update.effective_user.id, "admin", "rm_foto-menu")
    else:
        await update.message.reply_text("‚ùå N√£o h√° foto de menu salva.")

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para receber fotos"""
    if not is_admin(update.effective_user.id):
        return
    
    if context.user_data.get('waiting_menu_photo'):
        photo = update.message.photo[-1]
        file = await photo.get_file()
        await file.download_to_drive(MENU_PHOTO)
        
        await update.message.reply_text("‚úÖ Foto do menu salva com sucesso!")
        context.user_data['waiting_menu_photo'] = False
        add_log(update.effective_user.id, "admin", "foto_menu_salva")

# ==================== CALLBACK HANDLERS ====================
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para callbacks de bot√µes"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    if is_banned(user_id):
        await query.message.edit_text(
            "<blockquote>Voc√™ est√° banido.</blockquote>",
            parse_mode=ParseMode.HTML
        )
        return
    
    add_log(user_id, "botao", data)
    
    # Menu principal
    if data == "back_menu":
        config = get_config()
        greeting = config.get("greeting", "Ol√°! Bem-vindo ao bot.")
        
        text = (
            f"<blockquote>{greeting}</blockquote>\n\n"
            f"<b>{BOT_NAME} {BOT_VERSION}</b>\n"
            f"Ol√°, <b>{query.from_user.full_name}</b>! Escolha uma op√ß√£o:"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîç Google Dork", callback_data="google_dork")],
            [InlineKeyboardButton("üìä Meus Logs", callback_data="my_logs")],
            [InlineKeyboardButton("‚ö†Ô∏è Reportar Erro", callback_data="report_error")],
            [InlineKeyboardButton("üí¨ Suporte", callback_data="suporte")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Editar com ou sem foto
        if MENU_PHOTO.exists() and query.message.photo:
            await query.message.edit_caption(
                caption=text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
        else:
            await query.message.edit_text(
                text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
    
    elif data == "google_dork":
        text = (
            "<b>üîç Google Dork</b>\n\n"
            "Use o comando:\n"
            "<code>/dork &lt;termo&gt;</code>\n\n"
            "<i>Exemplo: /dork joao</i>"
        )
        keyboard = [[InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data == "my_logs":
        logs = get_logs()
        user_logs = logs.get(str(user_id), [])
        
        if not user_logs:
            text = "<b>üìä Meus Logs</b>\n\n<i>Voc√™ ainda n√£o possui logs.</i>"
            keyboard = [[InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")]]
        else:
            # Pagina√ß√£o
            page = 0
            per_page = 5
            start_idx = page * per_page
            end_idx = start_idx + per_page
            
            logs_page = user_logs[start_idx:end_idx]
            
            text = f"<b>üìä Meus Logs (P√°gina {page + 1}):</b>\n\n<pre>"
            for log in logs_page:
                text += f"[{log['timestamp']}]\n"
                text += f"A√ß√£o: {log['action']}\n"
                text += f"Detalhes: {log.get('details', 'N/A')}\n"
                text += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
            text += "</pre>"
            
            keyboard = []
            nav_buttons = []
            
            if end_idx < len(user_logs):
                nav_buttons.append(InlineKeyboardButton("Pr√≥ximo ¬ª", callback_data=f"logs_page_{page+1}"))
            
            if nav_buttons:
                keyboard.append(nav_buttons)
            
            keyboard.append([InlineKeyboardButton("üóëÔ∏è Limpar Meus Logs", callback_data="clear_logs")])
            keyboard.append([InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data.startswith("logs_page_"):
        page = int(data.split("_")[-1])
        logs = get_logs()
        user_logs = logs.get(str(user_id), [])
        
        per_page = 5
        start_idx = page * per_page
        end_idx = start_idx + per_page
        
        logs_page = user_logs[start_idx:end_idx]
        
        text = f"<b>üìä Meus Logs (P√°gina {page + 1}):</b>\n\n<pre>"
        for log in logs_page:
            text += f"[{log['timestamp']}]\n"
            text += f"A√ß√£o: {log['action']}\n"
            text += f"Detalhes: {log.get('details', 'N/A')}\n"
            text += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        text += "</pre>"
        
        keyboard = []
        nav_buttons = []
        
        if page > 0:
            nav_buttons.append(InlineKeyboardButton("¬´ Anterior", callback_data=f"logs_page_{page-1}"))
        
        if end_idx < len(user_logs):
            nav_buttons.append(InlineKeyboardButton("Pr√≥ximo ¬ª", callback_data=f"logs_page_{page+1}"))
        
        if nav_buttons:
            keyboard.append(nav_buttons)
        
        keyboard.append([InlineKeyboardButton("üóëÔ∏è Limpar Meus Logs", callback_data="clear_logs")])
        keyboard.append([InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data == "clear_logs":
        logs = get_logs()
        logs[str(user_id)] = []
        save_logs(logs)
        
        text = "<b>‚úÖ Seus logs foram limpos!</b>"
        keyboard = [[InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data == "report_error":
        text = (
            "<b>‚ö†Ô∏è Reportar Erro</b>\n\n"
            "Descreva o erro que voc√™ encontrou:"
        )
        keyboard = [[InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        context.user_data['waiting_report'] = True
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data == "suporte":
        config = get_config()
        suporte_msg = config.get("suporte_message", "Ol√°, preciso de ajuda!")
        
        text = "<b>üí¨ Suporte</b>\n\nEntre em contato: @suporte"
        keyboard = [
            [InlineKeyboardButton("üí¨ Enviar mensagem", url=f"https://t.me/suporte?text={suporte_msg}")],
            [InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if query.message.photo:
            await query.message.edit_caption(caption=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
        else:
            await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
    
    elif data.startswith("ids_page_"):
        page = int(data.split("_")[-1])
        users = get_users()
        
        per_page = 50
        start_idx = page * per_page
        end_idx = start_idx + per_page
        
        users_page = users[start_idx:end_idx]
        
        text = f"<b>üë• Usu√°rios Registrados (P√°gina {page + 1}):</b>\n\n"
        
        for user in users_page:
            text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            text += f"<b>Nome:</b> {user.get('nome', 'N/A')}\n"
            text += f"<b>Username:</b> @{user.get('username', 'sem username')}\n"
            text += f"<b>ID:</b> <code>{user.get('id')}</code>\n"
            text += f"<b>Start:</b> {user.get('start_date', 'N/A')}\n"
        
        text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        text += f"\n<i>Total: {len(users)} usu√°rios</i>"
        
        keyboard = []
        nav_buttons = []
        
        if page > 0:
            nav_buttons.append(InlineKeyboardButton("¬´ Anterior", callback_data=f"ids_page_{page-1}"))
        
        if end_idx < len(users):
            nav_buttons.append(InlineKeyboardButton("Pr√≥ximo ¬ª", callback_data=f"ids_page_{page+1}"))
        
        if nav_buttons:
            keyboard.append(nav_buttons)
        
        keyboard.append([InlineKeyboardButton("¬´ Voltar", callback_data="back_menu")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.message.edit_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para mensagens de texto"""
    user_id = update.effective_user.id
    
    if is_banned(user_id):
        return
    
    # Report
    if context.user_data.get('waiting_report'):
        report_text = update.message.text
        user = update.effective_user
        
        # Enviar para admin
        photos = await context.bot.get_user_profile_photos(user_id, limit=1)
        photo_url = None
        if photos.total_count > 0:
            photo_file = await photos.photos[0][-1].get_file()
            photo_url = photo_file.file_path
        
        admin_msg = (
            f"<b>‚ö†Ô∏è NOVO REPORT</b>\n\n"
            f"<b>De:</b> {user.full_name}\n"
            f"<b>Username:</b> @{user.username or 'sem username'}\n"
            f"<b>ID:</b> <code>{user_id}</code>\n"
            f"<b>Data:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        )
        
        if photo_url:
            admin_msg += f"<b>Foto:</b> <a href='{photo_url}'>Ver foto</a>\n"
        
        admin_msg += f"\n<b>Mensagem:</b>\n<blockquote>{report_text}</blockquote>"
        
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=admin_msg,
            parse_mode=ParseMode.HTML
        )
        
        await update.message.reply_text(
            "‚úÖ Seu report foi enviado para o administrador!",
            parse_mode=ParseMode.HTML
        )
        
        context.user_data['waiting_report'] = False
        add_log(user_id, "report", report_text)

# ==================== MAIN ====================
def main():
    """Fun√ß√£o principal"""
    # Criar estrutura
    create_structure()
    
    # Criar aplica√ß√£o
    application = Application.builder().token(TOKEN).build()
    
    application.bot_data['event_loop'] = asyncio.get_event_loop()

    
    # Handlers p√∫blicos
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("dork", dork_command))
    application.add_handler(CommandHandler("criar_design", criar_design_command))
    application.add_handler(CommandHandler("suporte", suporte_command))
    application.add_handler(CommandHandler("search_id", search_id_command))
    
    # Handlers admin   
    application.add_handler(CommandHandler("userinfo", userinfo_command))
    application.add_handler(CommandHandler("crypto", crypto_command))
    application.add_handler(CommandHandler("bitcoin", crypto_command))
    application.add_handler(CommandHandler("cep", cep_command))
    application.add_handler(CommandHandler("html", html_command))
    application.add_handler(CommandHandler("css", css_command))
    application.add_handler(CommandHandler("js", js_command))

    application.add_handler(CommandHandler("ip", ip_command))
    application.add_handler(CommandHandler("pkg", pkg_command))
    application.add_handler(CommandHandler("ban", ban_user))
    application.add_handler(CommandHandler("unban", unban_user))
    application.add_handler(CommandHandler("vip", vip_user))
    application.add_handler(CommandHandler("del_vip", del_vip_user))
    application.add_handler(CommandHandler("botoff", bot_maintenance))
    application.add_handler(CommandHandler("boton", bot_online))
    application.add_handler(CommandHandler("ids", ids_command))
    application.add_handler(CommandHandler("info_id", info_id_command))
    application.add_handler(CommandHandler("fotomenu", fotomenu_command))
    application.add_handler(CommandHandler("rm_foto_menu", rm_fotomenu_command))
    
    # Handlers de mensagens
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    
    # Callback handler
    application.add_handler(CallbackQueryHandler(handle_callback))
    
    # Iniciar thread de verifica√ß√£o VIP
    vip_thread = threading.Thread(target=vip_checker_thread, args=(application,), daemon=True)
    vip_thread.start()
    
    # Iniciar bot
    logger.info(f"{BOT_NAME} {BOT_VERSION} iniciado!")
    application.run_polling()

if __name__ == "__main__":
    main()
